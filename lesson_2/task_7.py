"""
Домашнее задание к уроку № 2 "Алгоритмы и структуры данных на Python"
Студент: Максим Сапунов Jenny6199@yandex.ru 19.07.2021

Задача № 7. Напишите программу, доказывающую или проверяющую, что для множества натуральных чисел
выполняется равенство: 1+2+...+n = n(n+1)/2, где n - любое натуральное число.
"""
import sys


def sum_next_digit(n: int, result=0):
    """
    Функция производит последовательное сложение всех чисел от 1 до n
    напр. 1+2+3+...n. Реализован рекурсивный алгоритм.
    :param n: int - крайний случай.
    :param result=0 переменная содержащая результат вычисления. На первой итерации равна 0.
    :return result: int - результат сложения всех чисел от 1 до n
    """
    result += n
    if n == 1:      # Крайний случай.
        return result
    elif n < 0:
        print('\033[031m Ошибка в полученных данных! '
              'Результат не может быть достоверно обработан данной программой.\033[0m')
        sys.exit()
    else:       # Рекурсивный случай
        return sum_next_digit(n-1, result)


def formula(n: int):
    """
    Функция вычисляет выражение n(n+1)/2
    :param n:int - целое число
    :return result:int - результат вычисления заданной формулы для заданного n.
    """
    return int(n*(n+1)/2)


def user_digit():
    """Запрашивает у пользователя число, производит обработку ошибок ввода и возвращает число в программу"""
    pass
    var1 = input('Введите целое число: ')
    try:
        return int(var1)
    except ValueError:
        print('\033[031m Ошибка! Введенные данные не являются натуральным числом!\033[0m\n '
              'Запустите программу повторно с правильными значениями.')
        sys.exit()


def check_opportunity(deep: int):
    """
    Функция проверяет возможность осуществление рекурсивного вызова с заданными параметрами.
    :param deep:int - запрашиваемая глубина рекурсии.
    :return True если полученный параметр не превышает допустимую глубину рекурсии установленную
    в системе пользователя, False если предел достигнут или превышен.
    """
    limit = sys.getrecursionlimit()
    if deep >= limit:
        print(f'\033[031m К сожалению программа не может обработать заданное число.\033[0m\n'
              f' Установленное в вашей системе значение глубины рекурсии составляет {limit}.\n'
              f' Если Вы хотите обработать большее число - воспользуйтесь sys.setrecursionlimit(n).\n'
              f' \033[01m\033[031mВнимание!\033[0m Использовать данный метод необходимо с осторожностью.\n'
              f' Запустите программу повторно с правильными значениями.')
        return False
    return True


def run():
    """Агрегация функций и запуск работы програмы."""
    decor = '-'*50
    print('Программа проверяет равенство двух выражений: \n'
          '(n * (n + 1) / 2) и  1 + 2 + 3.. + n для произвольного натурального числа.\n'
          'Возможности алгоритма ограничены глубиной рекурсии установленной в Вашей системе.\n')
    f = user_digit()
    if check_opportunity(f):
        var1 = sum_next_digit(f)
        var2 = formula(f)
        print(decor)
        print(f'\033[032m Посмотрите на результаты вычислений:\033[0m\n'
              f' Для выражения (n * (n + 1) / 2) при n = {f} результат - {var1}.\n'
              f' Для выражения  1 + 2 + 3.. + n при n = {f} результат - {var2}.\n'
              f' Таким образом: (n * (n + 1) / 2) = 1 + 2 + 3.. + n.\n'
              f' Что и требовалось доказать.')
        print(decor)


if __name__ == '__main__':
    run()
